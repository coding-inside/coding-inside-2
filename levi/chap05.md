## 🔎 복잡도

복잡도란 알고리즘의 성능, 효율성을 나타내는 척도이다. 크게 시간 복잡도(Time Complexity)와 공간 복잡도(Space Complexity)로 나눌 수 있다. 각 알고리즘이 주어진 특정 크기의 입력(n)을 기준으로 수행시간 혹은 사용 공간이 얼마나 되는지 객관적으로 비교할 수 있는 기준을 제시한다.

> 즉 **복잡도**란 어떤 알고리즘이 효율적인지 판단하는 척도이다.

복잡도를 나타내는 방법으로는 점근 표기법으로 O(빅오), Ω(오메가), Θ(세타) 등이 있고, 주로 빅오와 세타 표기법이 많이 사용된다.

## ⏰ 시간 복잡도

> **시간 복잡도**란 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수를 나타낸다.

알고리즘의 성능 평가 유형엔 최선, 평균, 최악이 있는데, 이 중 최악의 경우로 알고리즘을 성능 평가한다. 그 이유는 알고리즈이 복잡해질 수록 평균 성능을 구하기 어렵기도 하며, 나머지 경우 모두 최악의 경우보다는 빠르므로 최악의 경우가 앞선 두 경우를 모두 포함할 수 있기 때문이다.

> **최선의 경우(Best Case)**
> 최적의 입력을 한 상태에서, 작업을 완료하는 데 가장 연산 횟수가 적은 경우
> **평균의 경우 (Average Case)**
> 여러 경우의 수를 고려하여, 총 연산 횟수를 계산하고 시행 횟수로 나눈 경우
> **최악의 경우 (Worst Case)**
> 최악의 입력을 한 상태에서, 작업을 완료하는 데 가장 연산 횟수가 많은 경우

## 🎯 공간 복잡도

> **공간 복잡도**란 프로그램 실행과 완료에 얼마나 많은 공간가 필요한지를 나타낸다.

알고리즘을 실행시키기 위해 필요한 공간(space)는 두 가지로 나눌 수 있다.

> **고정 공간**
> 코드가 저장되는 공간, 알고리즘 실행을 위해 시스템이 필요로 하는 공간 등
> **가변 공간**
> 문제를 해결하기 위해 알고리즘이 필요로 하는 공간. 변수를 저장하는 공간, 순환 프로그램일 경우 순환 스택(recursion stack) 등

이때 프로그램이 필요로 하는 메모리 공간은 **고정 공간 요구 + 가변 공간 요구** 이다.

시간 복잡도는 얼마나 빠르게 실행되는지, 공간 복잡도는 얼마나 많은 자원이 필요한지를 판단한다. 시간 복잡도와 공간 복잡도는 반비례하는 경향이 있어, 보통 알고리즘의 성능을 판단할 때는 시간 복잡도를 위주로 판단한다.

## 📈 빅오 표기법

빅오는 점근적 실행 시간을 표기할때 가장 널리 쓰이는 수학적 표기 방법이다. 여기서 점근적 실행 시간이란 간단하게 n이라는 입력값이 무한대로 커질떄의 실행 시간의 추이를 의미한다.

> 즉 **빅오 표기법**은 인자가 특정한 값이나 무한대로 향할 때 함수의 극한적인 동작을 설명하는 수학적인 표기법입니다.

따라서 충분히 큰 입력값에서의 알고리즘의 효율성에 따라 수행 시간이 크게 차이가 날 수 있다. 이때 점근적 실행 시간을 달리 말하면 **시간 복잡도라** 할 수 있다.

![](https://velog.velcdn.com/images/psik_2/post/1deaf0d3-5cb9-4d99-89ff-f4619cf928c2/image.png)

> **빅오 표기법의 종류**
>
> **O(1)** : 입력값에 상관없이 일정한 실행시간을 최고의 알고리즘이라 할 수 있다. 하지만 상수 시간에 실행된다 해도 상수값이 상상 이상으로 클 경우 사실상 일정한 시간의 의미가 없다. 최고의 알고리즘이 될 수 있지만 그만큼 신중해야 한다.
>
> **O(log n)** : 로그는 매우 큰 입력값에서도 크게 영향을 받지 않는 편이다. 매우 견고한 알고리즘으로 이진 탐색의 경우가 이에 해당한다.
>
> **O(n)** : 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간 알고리즘이라 부른다. 정렬되지 않은리스트에서 최대 또는 최솟값을 찾는 경우가 해당되며 모든 입렵값을 적어도 한 번 이상은 살펴봐야 한다.
>
> **O (n log n)** : 병합 정렬등의 대부분 효율이 좋은 알고리즘이 이에 해당 한다. 아무리 좋은 알고리즘이라 할지라도 n log n 보다 빠를 수 없다. 입력값이 최선일 경우, 비교를 건너 뛰어 O(n)이 될 수 있다.
>
> **O(n^2)** : 버블 정렬 같은 비효율저긴 정렬 알고리즘이 이에 해당 한다.
>
> **O(2^n)** : 피보나치의 수를 재귀로 계산하는 알고리즘이 이에 해당 한다. n^2와 혼동되는 경우가 있는데 2^n이 훨씬 더 크다.

빅오 표기법을 설명하면 상한, 최선, 최악이란 단어를 자주 사용한다. 그렇다면 이 것들은 무슨 말일까?

빅오(O)는 상한을 의미한다. 하한을 의미하는 빅오메가, 평균을 의미하는 빅세타가 있지만 보통 빅오만을 사용한다. 빅오 표기법이 가장 많이 사용되는 이유는 알고리즘 효율성을 상한선 기준으로 표기하기 때문이다. 다시 말해 최악의 경우를 고려하는 데 가장 좋은 표기법이다.

이때까지 시간 복잡도와 빅오 표기법에 대해 알아보았는데 그렇다면 공간 복잡도와 빅오 표기법은 어떻게 될까?

공간 복잡도는 알고리즘 실행에 메모리가 얼마나 사용되는지를 계산하면 된다.

예를 들어 크기가 n인 배열을 입력으로 주었을 때, 알고리즘이 n \* n의 이차원 배열을 생성한다면 이 알고리즘의 공간 복잡도는 n^2이다. 알고리즘의 공간 복잡도를 계산한 후 상수항과 영향력 없는 항을 무시해 나타내면 빅오 표기법이 된다.
